use num::bigint::{self, BigInt, ToBigInt};
use num::traits::{One, Zero};
fn main() {
    let a = BigInt::parse_bytes(b"96557807278640299121519463045206377934978887298086994211590515571717325955785923783159432436307870512742354877476790046891802153053719263845602618422474671707896136814707875793300040916757228826108499490311295942553478010913043680523612655400526255290702983490382191419067057726624348815391509161304477322782",10);
    let b = BigInt::parse_bytes(b"146116799305702219220540123503890666704710410600856387071776221592477256752759997798169931809156426471243799795374072510423645363680537337813774268658907130969994146783451692837222772144941434909050652825715582967684984814095461041109999161468223272534833391335036612863782740784573110824091866969655931097032",10);
    let c = b.unwrap();
    let d = a.unwrap();
    let e = gcd(&c, &d);
    let key = ex_gcd(
        &(Zero::zero(), One::one(), c),
        &(One::one(), Zero::zero(), d),
    );
    println!("{}", e);
    println!("{:?}", key);
    let x = BigInt::parse_bytes(b"448491664748214835887077572737743989471818983924746533195711112723370968680112145505675868905886297697651811535959153343019297445815718781370807622258565317729681110144781420923700723193680834808549790079348059612669341617763791748262779560287414722951999863579554855226385841903174595011558143906566236113746355880815410935162653615576832860612181499713446185302492149321184607038850277", 10).unwrap();
    let n = BigInt::parse_bytes(b"266848195381815818463717950266554236453862598799637312683425703733349860929573593996414020829279843574050749733141808826377733991992433000295290381444934817157435190251178268111713086611665708753888640498769964215272509919856595016440707694201919276657450513307401642404169770745634306482286288562684063317756864776774548994812022552274677735053131675109617882635817658233698378909301711242970820585209428037532351125028227556492657705501994644156977193457255573644987541990311834672767028439520378145222935082885623390192713665176848108677291865357438200", 10).unwrap();
    let m = BigInt::parse_bytes(b"26449610480694582663087914798262349275307583705769208320615999887968533547578043032399193471649467130397212338172281740898344480836053483980415141663259446884375373371451231004101622624801199838411707260636384692208754088842619258012627585405663559933995516981379631336446313020148817646717985549051301115238527677472914852742788256890259402224899453419484216558327523122341749054612967901747155276100157913910547784136439888489952724508554613632641420487039242881743232756168292709989984925436911267322885917953348064673021283822937158706678666372103627074163021260578078017304088904154859161289037070912220207946945", 10).unwrap();
    let ans = fast_pow(&x, &n, &m);
    println!("{}", ans);
    let v = vec![
        [
            BigInt::parse_bytes(b"13392316081651420877308875276166772808601812122052371442339078877740399569281672683820206196320955005869072002883847646526584107260355414977120453263391947",10).unwrap(),
            BigInt::parse_bytes(b"8157969540288411637818433039558323184074779086100165504668538221920170369774913261335059602331627321130656458962980224196880533337839226059601303464776145",10).unwrap(),
        ],
        [
            BigInt::parse_bytes(b"9734466939658282823343760206593283968765904848250021580218634383869090913086348857668999272399075016287736914000854272239315769632719896968098820774563511",10).unwrap(),
            BigInt::parse_bytes(b"9699616044315021194953572561076502992783130623216574220426043600142343504101508838526221359049417564415801914072315788919275792502477693022853881785198116",10).unwrap(),
        ],
        [
            BigInt::parse_bytes(b"9460200357790728398862913232664036038694521858415765931064505193755202156521446156499075450033429983317127589636591133111239548821251790171694322930011927",10).unwrap(),
            BigInt::parse_bytes(b"7832693802256371667866514213119452199821916193668106904135812283217637737600922381702016472708855675649121271702977408217814917908566132517503707494037556",10).unwrap(),
        ],
    ];
    let (b, m) = crt(&v);
    println!("{}mod{}", b, m);
    let p = BigInt::parse_bytes(b"8123641848146819461941469161168273481264121", 10).unwrap();
    println!("{}", miller_rabin(&p));
}
fn gcd(a: &BigInt, b: &BigInt) -> BigInt {
    return if (*b).is_zero() {
        a.clone()
    } else {
        gcd(b, &(a % b))
    };
}
fn ex_gcd(a: &(BigInt, BigInt, BigInt), b: &(BigInt, BigInt, BigInt)) -> (BigInt, BigInt, BigInt) {
    return if a.2.is_zero() {
        let c = b.clone();
        (c.1, c.0, c.2)
    } else {
        let c = a.clone();
        let d = b.clone();
        let q = &(d.2) / &(c.2);
        let t1 = d.0 - &q * c.0;
        let t2 = d.1 - &q * c.1;
        let t3 = d.2 - &q * c.2;
        ex_gcd(&(t1, t2, t3), a)
    };
}
fn get_inv(a: &BigInt, b: &BigInt) -> BigInt {
    let c = (BigInt::zero(), BigInt::one(), a.clone());
    let d = (BigInt::one(), BigInt::zero(), b.clone());
    let (ans, _t, _tmp) = ex_gcd(&c, &d);
    return ans;
}
fn fast_pow(x: &BigInt, n: &BigInt, m: &BigInt) -> BigInt {
    let mut rs = BigInt::one();
    let mut base = x.clone();
    let mut exp = n.clone();
    let md = m.clone();
    let two = ToBigInt::to_bigint(&2).unwrap();
    while exp > BigInt::zero() {
        if &exp & &BigInt::one() == BigInt::one() {
            rs = (rs * &base) % &md;
        }
        base = &base * base.clone() % &md;
        exp = exp / &two;
    }
    return rs;
}
fn get_mi(ls: &Vec<[BigInt; 2]>) -> (Vec<[BigInt; 2]>, BigInt) {
    let mut m = BigInt::one();
    let mut rs: Vec<[BigInt; 2]> = Vec::new();
    for pair in ls.iter() {
        m = m.clone() * &pair[0];
    }
    for pair in ls.iter() {
        println!("{},{}", pair[0], pair[1]);
        rs.push([pair[0].clone(), &m / &pair[0]]);
    }
    return (rs, m);
}
fn get_ms_inv(ls: &Vec<[BigInt; 2]>) -> Vec<BigInt> {
    let mut rs: Vec<BigInt> = Vec::new();
    for pair in ls.iter() {
        rs.push(get_inv(&pair[1], &pair[0]));
    }
    return rs;
}
fn crt(ls: &Vec<[BigInt; 2]>) -> (BigInt, BigInt) {
    let mut x = BigInt::zero();
    let (ms, m) = get_mi(ls);
    let es = get_ms_inv(&ms);
    for i in 0..ls.len() {
        x = (x.clone() + &ms[i][1] * &es[i] * &ls[i][1]) % &m;
    }
    return (x, m);
}
fn miller_rabin(p: &BigInt) -> (bool) {
    let two = ToBigInt::to_bigint(&2).unwrap();
    if p < &ToBigInt::to_bigint(&3).unwrap() {
        return p == &two;
    }
    let random_times = 10;
    let mut q = p - BigInt::one();
    let mut t = 0;
    while q % two == BigInt::zero() {
        q = q / two;
        t += 1;
    }
    for i in 0..random_times {
        let a = bigint::RandBigInt::gen_bigint_range(BigInt::one(), p - &BigInt::one());
        let mut v = fast_pow(&a, &q, &p);
        if v == BigInt::one() || v == p - BigInt::one() {
            continue;
        }
        for j in 0..t + 1 {
            v = v * v % p;
            if v == p - BigInt::one() {
                break;
            }
        }
        return false;
    }
    return true;
}
